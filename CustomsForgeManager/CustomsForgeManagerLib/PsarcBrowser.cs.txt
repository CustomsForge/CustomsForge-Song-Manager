using System.Diagnostics;
using CustomsForgeManager.CustomsForgeManagerLib.Objects;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using RocksmithToolkitLib.DLCPackage;
using RocksmithToolkitLib.Extensions;
using RocksmithToolkitLib.PSARC;

namespace CustomsForgeManager.CustomsForgeManagerLib
{
    public class PsarcBrowser : IDisposable
    {
        private string FilePath;
        private PSARC archive;

        // Loads song archive file to memory.
        public PsarcBrowser(string filePath)
        {
            FilePath = filePath;
            archive = new PSARC();
            var stream = File.OpenRead(FilePath);
            archive.Read(stream, true);
        }

        public IEnumerable<SongData> GetSongs()
        {
            var sw = new Stopwatch();
            sw.Restart();

            string author = String.Empty;
            string version = String.Empty;
            string tkversion = String.Empty;
            var songsFromPsarcFileList = new List<SongData>();

            var toolkitVersionFiles = archive.TOC.Where(x => (x.Name.Equals("toolkit.version")));
            // does not throw error if CDLC does not have toolkit.version file (good)
            foreach (var toolkitVersionFile in toolkitVersionFiles)
            {
                if (toolkitVersionFile.Name.Equals("toolkit.version"))
                {
                    //if (toolkitVersionFile.Compressed)// it's planned
                    archive.InflateEntry(toolkitVersionFile);
                    ToolkitInfo tkInfo = GeneralExtensions.GetToolkitInfo(new StreamReader(toolkitVersionFile.Data));
                    author = tkInfo.PackageAuthor ?? "N/A";
                    version = tkInfo.PackageVersion ?? "N/A";
                    tkversion = tkInfo.ToolkitVersion ?? "N/A";
                }
            }

            // TODO: fix Vocals parsing and display
            // assumption that each song contains showlights may not be valid
            var singleSongCount = archive.TOC.Where(x => x.Name.Contains("showlights.xml") && x.Name.Contains("arr"));

            foreach (var singleSong in singleSongCount)
            {
                string strippedName = singleSong.Name.Replace("_showlights.xml", "").Replace("songs/arr/", "");
                var infoFiles = archive.TOC.Where(x =>
                    x.Name.StartsWith("manifests/songs")
                    && !x.Name.Contains("vocals")
                    && x.Name.EndsWith(".json")
                    && x.Name.Contains(strippedName)
                ).OrderBy(x => x.Name);

                var currentSong = new SongData { Author = author, Version = version, ToolkitVer = tkversion, Path = FilePath };

                // little speed hack ... some only need to be done one time
                foreach (var entry in infoFiles)
                {
                    archive.InflateEntry(entry);
                    using (var ms = new MemoryStream())
                    using (var reader = new StreamReader(ms, new UTF8Encoding(), false, 65536))//4Kb is default alloc sise for windows.. 64Kb is default PSARC alloc
                    {
                        entry.Data.CopyTo(ms);
                        entry.Data.Position = 0;
                        ms.Position = 0;

                        var o = JObject.Parse(reader.ReadToEnd());
                        var attributes = o["Entries"].First.Last["Attributes"];
                        // these don't change so skip after first
                        currentSong.Title = attributes["SongName"].ToString();
                        currentSong.Artist = attributes["ArtistName"].ToString();
                        currentSong.Album = attributes["AlbumName"].ToString();
                        currentSong.SongYear = attributes["SongYear"].ToString();
                        currentSong.Updated = attributes["LastConversionDateTime"].ToString();
                        currentSong.ArtistTitleAlbum = String.Format("{0};{1};{2}", currentSong.Artist, currentSong.Title, currentSong.Album);
                        currentSong.Arrangements = attributes["Arrangement"].ToString();
                        // remember to preload tuning definitions
                        currentSong.Tuning = Extensions.TuningToName(attributes["Tuning"].ToString());
                        currentSong.DD = attributes["MaxPhraseDifficulty"].ToString(); // .DifficultyToDD();
                    }

                    songsFromPsarcFileList.Add(currentSong);
                }
            }
            sw.Stop();
            Globals.Log(Path.GetFileName(FilePath) + " : " + sw.ElapsedMilliseconds + " milliSeconds");
            return songsFromPsarcFileList;
        }

        public void Dispose()
        {
            archive.Dispose();
            GC.SuppressFinalize(this);
        }

    }
}
